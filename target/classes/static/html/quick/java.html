<div class="jumbotron">
    <h3 class="text-primary">Java</h3>
</div>
<div>
    <ul class="nav nav-tabs" role="tablist" id="totalTabs">
        <li role="presentation" class="active"><a href="#total_tab0" aria-controls="total_tab1" role="tab"
                                                  data-toggle="tab">八股文</a></li>
        <li role="presentation"><a href="#total_tab1" aria-controls="total_tab1" role="tab" data-toggle="tab">JVM</a>
        </li>
        <li role="presentation"><a href="#total_tab2" aria-controls="total_tab2" role="tab" data-toggle="tab">垃圾回收</a>
        </li>
        <li role="presentation"><a href="#total_tab3" aria-controls="total_tab3" role="tab" data-toggle="tab">IO/NIO</a>
        </li>
        <li role="presentation"><a href="#total_tab4" aria-controls="total_tab4" role="tab" data-toggle="tab">集合</a>
        </li>
        <li role="presentation"><a href="#total_tab5" aria-controls="total_tab5" role="tab" data-toggle="tab">多线程</a>
        </li>
        <li role="presentation"><a href="#total_tab6" aria-controls="total_tab6" role="tab" data-toggle="tab">锁</a>
        </li>
        <li role="presentation"><a href="#total_tab7" aria-controls="total_tab7" role="tab" data-toggle="tab">队列</a>
        </li>
        <li role="presentation" class="dropdown">
            <a href="" class="dropdown-toggle" data-toggle="dropdown"
               aria-controls="total_tab8" aria-expanded="false">异常&反射&泛型&代理<span class="caret"></span></a>
            <ul class="dropdown-menu" aria-labelledby="myTabDrop1" id="myTabDrop1-contents">
                <li class=""><a href="#total_tab8_1" role="tab" data-toggle="tab"
                                aria-controls="total_tab8_1" aria-expanded="true">异常</a></li>
                <li class=""><a href="#total_tab8_2" role="tab" data-toggle="tab"
                                aria-controls="total_tab8_2" aria-expanded="false">反射</a></li>
                <li class=""><a href="#total_tab8_3" role="tab" data-toggle="tab"
                                aria-controls="total_tab8_3" aria-expanded="false">泛型</a></li>
                <li class=""><a href="#total_tab8_4" role="tab" data-toggle="tab"
                                aria-controls="total_tab8_4" aria-expanded="false">代理</a></li>
            </ul>
        </li>
    </ul>
    <div class="tab-content">
        <div role="tabpanel" class="tab-pane active" id="total_tab0">
            不会八股文，面试第一关就暴毙QAQ
        </div>
        <div role="tabpanel" class="tab-pane" id="total_tab1">
            <div class="panel panel-default">
                <div class="panel-body" style="overflow: auto;">
                    <img src="/static/img/quick/java/jvm.webp"></div>
            </div>
        </div>
        <div role="tabpanel" class="tab-pane" id="total_tab2">垃圾回收</div>
        <div role="tabpanel" class="tab-pane" id="total_tab3">IO/NIO</div>
        <div role="tabpanel" class="tab-pane" id="total_tab4">
            <p class="text-primary">看不全全图说明您的设备屏幕太小，分辨率过低。</p>
            <ul>
                <li>台式机玩家使用滚轮横向滚动，使用Shift+滚轮横向滚动。</li>
                <li>笔记本玩家两指竖划竖向滚动，两指横划横向滚动。</li>
                <li>手机玩家直接挫图即可任何方向滚动。</li>
            </ul>
            <div class="panel panel-default">
                <div class="panel-body" style="overflow: auto;">
                    <img src="/static/img/quick/java/collection.webp">
                </div>
            </div>
        </div>
        <div role="tabpanel" class="tab-pane" id="total_tab5">
            <div class="panel panel-default">
                <div class="panel-body" style="overflow: auto;">
                    <img src="/static/img/quick/java/thread.png"></div>
            </div>
        </div>
        <div role="tabpanel" class="tab-pane table-responsive" id="total_tab6">
            <table class="table table-bordered table-hover">
                <tr class="info">
                    <th>概念</th>
                    <th>所在分组</th>
                    <th>说明</th>
                </tr>
                <tr>
                    <td>乐观锁</td>
                    <td>乐观锁，悲观锁</td>
                    <td>乐观锁是一种乐观思想，即认为读多写少，遇到并发写的可能性低，每次去拿数据的时候都认为
                        别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数
                        据，采取在写时先读出当前版本号，然后加锁操作（比较跟上一次的版本号，如果一样则更新），
                        如果失败则要重复读-比较-写的操作。<br>
                        java 中的乐观锁基本都是通过 CAS 操作实现的，CAS 是一种更新的原子操作，比较当前值跟传入
                        值是否一样，一样则更新，否则失败。
                    </td>
                </tr>
                <tr>
                    <td>悲观锁</td>
                    <td>乐观锁，悲观锁</td>
                    <td>悲观锁是就是悲观思想，即认为写多，遇到并发写的可能性高，每次去拿数据的时候都认为别人
                        会修改，所以每次在读写数据的时候都会上锁，这样别人想读写这个数据就会 block 直到拿到锁。
                        java中的悲观锁就是Synchronized,AQS框架下的锁则是先尝试cas乐观锁去获取锁，获取不到，
                        才会转换为悲观锁，如 RetreenLock。
                    </td>
                </tr>
                <tr>
                    <td>自旋锁</td>
                    <td>自旋锁</td>
                    <td>自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁
                        的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），
                        等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。<br>
                        线程自旋是需要消耗 cup 的，说白了就是让 cup 在做无用功，如果一直获取不到锁，那线程
                        也不能一直占用 cup 自旋做无用功，所以需要设定一个自旋等待的最大时间。<br>
                        如果持有锁的线程执行的时间超过自旋等待的最大时间扔没有释放锁，就会导致其它争用锁
                        的线程在最大等待时间内还是获取不到锁，这时争用线程会停止自旋进入阻塞状态。
                    </td>
                </tr>
                <tr>
                    <td>Synchronized 同步锁</td>
                    <td>Synchronized</td>
                    <td>synchronized 它可以把任意一个非 NULL 的对象当作锁。他属于独占式的悲观锁，同时属于可重
                        入锁。
                    </td>
                </tr>
                <tr>
                    <td>公平锁</td>
                    <td>公平锁，非公平锁</td>
                    <td>加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得。</td>
                </tr>
                <tr>
                    <td>非公平锁</td>
                    <td>公平锁，非公平锁</td>
                    <td>加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待<br>
                        1. 非公平锁性能比公平锁高 5~10 倍，因为公平锁需要在多核的情况下维护一个队列<br>
                        2. Java 中的 synchronized 是非公平锁，ReentrantLock 默认的 lock()方法采用的是非公平锁。
                    </td>
                </tr>
                <tr>
                    <td>独占锁</td>
                    <td>共享锁，独占锁</td>
                    <td>独占锁模式下，每次只能有一个线程能持有锁，ReentrantLock 就是以独占方式实现的互斥锁。
                        独占锁是一种悲观保守的加锁策略，它避免了读/读冲突，如果某个只读线程获取锁，则其他读线
                        程都只能等待，这种情况下就限制了不必要的并发性，因为读操作并不会影响数据的一致性。
                    </td>
                </tr>
                <tr>
                    <td>共享锁</td>
                    <td>共享锁，独占锁</td>
                    <td>共享锁则允许多个线程同时获取锁，并发访问 共享资源，如：ReadWriteLock。共享锁则是一种
                        乐观锁，它放宽了加锁策略，允许多个执行读操作的线程同时访问共享资源。
                    </td>
                </tr>

                <tr>
                    <td>重量级锁</td>
                    <td>无锁，偏向锁，轻量级锁，重量级锁</td>
                    <td>Synchronized 是通过对象内部的一个叫做监视器锁（monitor）来实现的。但是监视器锁本质又
                        是依赖于底层的操作系统的 Mutex Lock 来实现的。而操作系统实现线程之间的切换这就需要从用
                        户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么
                        Synchronized 效率低的原因。因此，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为
                        “重量级锁”。JDK 中对 Synchronized 做的种种优化，其核心都是为了减少这种重量级锁的使用。
                        JDK1.6 以后，为了减少获得锁和释放锁所带来的性能消耗，提高性能，引入了“轻量级锁”和
                        “偏向锁”。
                    </td>
                </tr>
                <tr>
                    <td>轻量级锁</td>
                    <td>无锁，偏向锁，轻量级锁，重量级锁</td>
                    <td>随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁（但是锁的升级是单向的，
                        也就是说只能从低到高升级，不会出现锁的降级）。<br>
                        “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的。但是，首先需要强调一点的是，
                        轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量
                        级锁使用产生的性能消耗。在解释轻量级锁的执行过程之前，先明白一点，轻量级锁所适应的场
                        景是线程交替执行同步块的情况，如果存在同一时间访问同一锁的情况，就会导致轻量级锁膨胀
                        为重量级锁。
                    </td>
                </tr>
                <tr>
                    <td>偏向锁</td>
                    <td>无锁，偏向锁，轻量级锁，重量级锁</td>
                    <td>Hotspot 的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线
                        程多次获得。偏向锁的目的是在某个线程获得锁之后，消除这个线程锁重入（CAS）的开销，看起
                        来让这个线程得到了偏护。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级
                        锁执行路径，因为轻量级锁的获取及释放依赖多次 CAS 原子指令，而偏向锁只需要在置换
                        ThreadID 的时候依赖一次 CAS 原子指令（由于一旦出现多线程竞争的情况就必须撤销偏向锁，所
                        以偏向锁的撤销操作的性能损耗必须小于节省下来的 CAS 原子指令的性能消耗）。上面说过，轻
                        量级锁是为了在线程交替执行同步块时提高性能，而偏向锁则是在只有一个线程执行同步块时进
                        一步提高性能。
                    </td>
                </tr>
                <tr>
                    <td>分段锁</td>
                    <td>分段锁</td>
                    <td>分段锁也并非一种实际的锁，而是一种思想 ConcurrentHashMap 是学习分段锁的最好实践</td>
                </tr>

            </table>
        </div>
        <div role="tabpanel" class="tab-pane" id="total_tab7">队列</div>
        <div role="tabpanel" class="tab-pane" id="total_tab8_1">异常</div>
        <div role="tabpanel" class="tab-pane" id="total_tab8_2">反射</div>
        <div role="tabpanel" class="tab-pane" id="total_tab8_3">泛型</div>
        <div role="tabpanel" class="tab-pane" id="total_tab8_4">
            <div class="panel panel-primary">
                <div class="panel-heading">综述</div>
                <div class="panel-body">
                    代理分为静态代理，动态代理<br>
                    动态代理又分为JDK动态代理和CGLIB动态代理。<br>
                    使用CGLIB动态代理需要三方包依赖，MAVEN配置↓<br><br>
                    &lt;dependency&gt;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;groupId&gt;cglib&lt;/groupId&gt;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;artifactId>cglib&lt;/artifactId&gt;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&lt;version&gt;3.3.0&lt;/version&gt;<br>
                    &lt;/dependency&gt;<br><br>
                    当然，Spring需要使用CGLIB动态代理来实现AOP，所以如果已经引入了Spring，就无需再引入单独引用CGLIB了
                </div>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading">静态代理</div>
                <div class="panel-body">
                    <pre>
//接口
public interface BizService {
    void test();
}

//被代理的类
public class BizServiceImpl implements BizService {
    @Override
    public void test() {
        System.out.println("原始方法");
    }
}

//代理类
public class BizServiceProxy implements BizService {

    private BizService bizService;

    public BizServiceProxy(BizService bizService) {
        this.bizService = bizService;
    }

    @Override
    public void test() {
        System.out.println("代理方法前");
        bizService.test();
        System.out.println("代理方法后");
    }
}

//测试
public class StaticProxyTest {
    public static void main(String[] args) {
        BizServiceProxy proxy = new BizServiceProxy(new BizServiceImpl());
        proxy.test();
    }
}
                    </pre>
                    <pre>
运行结果：

代理方法前
原始方法
代理方法后
                    </pre>
                </div>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading">JDK动态代理</div>
                <div class="panel-body">
                    <pre>
//接口
public interface BizService {
    void test();
}

//被代理的类
public class BizServiceImpl implements BizService {
    @Override
    public void test() {
        System.out.println("原始方法");
    }
}

//代理类
public class BizServiceJDKProxy implements InvocationHandler {

    private Object object;

    public BizServiceJDKProxy(Object object) {
        this.object = object;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //被代理的对象↑，要执行的方法↑，方法参数↑
        System.out.println("代理方法前");
        Object methodResult = method.invoke(object, args);<span class="text-danger">//注意这里一定要用object，而不是参数中的proxy</span>
        //原因：本类中的object是被代理前的类，而参数中的proxy是代理后的类，使用代理后的类会造成递归死循环，不断执行"代理方法前"
        System.out.println("代理方法后");
        return methodResult;
    }
}

//测试
public class JDKProxyTest {
    public static void main(String[] args) {
        BizService bizService = new BizServiceImpl();//标准写法！前边是接口，后边是实现类。错误书写将会造成程序报错。所以使用JDK动态代理，被代理的类必须实现一个接口！
        Object proxyObj = Proxy.newProxyInstance(bizService.getClass().getClassLoader(), bizService.getClass().getInterfaces(), new BizServiceJDKProxy(bizService));
        BizService bizServiceProxy = (BizService) proxyObj;//同样标准写法，不可强转实现类，只能强转为接口。
        bizServiceProxy.test();
    }
}
                    </pre>
                    <pre>
运行结果：

代理方法前
原始方法
代理方法后
                    </pre>
                </div>
            </div>
            <div class="panel panel-default">
                <div class="panel-heading">CGLIB动态代理</div>
                <div class="panel-body">
                    <pre>
//接口
public interface BizService {
    void test();
}

//被代理的类
public class BizServiceImpl implements BizService {
    @Override
    public void test() {
        System.out.println("原始方法");
    }
}

//代理类
public class BizServiceCGLIBProxy implements MethodInterceptor {

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        //被代理的对象↑，要执行的方法↑，方法参数↑，代理的方法↑
        System.out.println("代理方法前");
        Object resultObj =methodProxy.invokeSuper(o, objects);
        System.out.println("代理方法后");
        return resultObj;
    }
}

//测试
public class CglibProxyTest {
    public static void main(String[] args) {
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(BizServiceImpl.class);//CGLIB可以直接代理类，不管类是否实现接口
        enhancer.setCallback(new BizServiceCGLIBProxy());
        BizServiceImpl bizService = (BizServiceImpl) enhancer.create();
        bizService.test();
    }
}
                    </pre>
                    <pre>
运行结果：

代理方法前
原始方法
代理方法后
                    </pre>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('#totalTabs a').click(function (e) {
            e.preventDefault()
            $(this).tab('show')
        })
    });
</script>